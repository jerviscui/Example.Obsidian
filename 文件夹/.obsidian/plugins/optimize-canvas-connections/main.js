/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OptimizeCanvasConnectionsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var OptimizeCanvasConnectionsPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.addCommand({
      id: "optimize-preserve-axes-selection",
      name: "Optimize selection (preserve axes)",
      checkCallback: (checking) => {
        const canvasView = app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if ((canvasView == null ? void 0 : canvasView.getViewType()) == "canvas") {
          if (!checking) {
            this.optimize("preserve-axes");
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "optimize-shortest-path-selection",
      name: "Optimize selection (shortest path)",
      checkCallback: (checking) => {
        const canvasView = app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if ((canvasView == null ? void 0 : canvasView.getViewType()) == "canvas") {
          if (!checking) {
            this.optimize("shortest-path");
          }
          return true;
        }
        return false;
      }
    });
  }
  onunload() {
  }
  async optimize(option) {
    const canvasView = app.workspace.getActiveViewOfType(import_obsidian.ItemView);
    const canvas = canvasView == null ? void 0 : canvasView.canvas;
    const currentSelection = canvas == null ? void 0 : canvas.selection;
    let selectedIDs = new Array();
    currentSelection.forEach(function(selection) {
      selectedIDs.push(selection.id);
    });
    let applyToAll = false;
    if (selectedIDs.length == 0) {
      applyToAll = true;
    }
    for (let [edgeKey, edge] of canvas["edges"]) {
      let fromNode = edge["from"]["node"];
      let toNode = edge["to"]["node"];
      let fromPossibilities = [edge["from"]["side"]];
      if (applyToAll || selectedIDs.includes(fromNode["id"])) {
        switch (option) {
          case "shortest-path":
            fromPossibilities = ["top", "bottom", "left", "right"];
            break;
          case "preserve-axes":
            switch (edge["from"]["side"]) {
              case "top":
              case "bottom":
                fromPossibilities = ["top", "bottom"];
                break;
              case "left":
              case "right":
                fromPossibilities = ["left", "right"];
                break;
            }
        }
      }
      let toPossibilities = [edge["to"]["side"]];
      if (applyToAll || selectedIDs.includes(toNode["id"])) {
        switch (option) {
          case "shortest-path":
            toPossibilities = ["top", "bottom", "left", "right"];
            break;
          case "preserve-axes":
            switch (edge["to"]["side"]) {
              case "top":
              case "bottom":
                toPossibilities = ["top", "bottom"];
                break;
              case "left":
              case "right":
                toPossibilities = ["left", "right"];
                break;
            }
        }
      }
      let distances = [];
      for (const fromSide of fromPossibilities) {
        let fromPoint = { "x": 0, "y": 0 };
        if (fromSide == "top") {
          fromPoint = { "x": fromNode["x"] + fromNode["width"] / 2, "y": fromNode["y"] };
        } else if (fromSide == "bottom") {
          fromPoint = { "x": fromNode["x"] + fromNode["width"] / 2, "y": fromNode["y"] + fromNode["height"] };
        } else if (fromSide == "left") {
          fromPoint = { "x": fromNode["x"], "y": fromNode["y"] + fromNode["height"] / 2 };
        } else if (fromSide == "right") {
          fromPoint = { "x": fromNode["x"] + fromNode["width"], "y": fromNode["y"] + fromNode["height"] / 2 };
        }
        for (const toSide of toPossibilities) {
          let toPoint = { "x": 0, "y": 0 };
          if (toSide == "top") {
            toPoint = { "x": toNode["x"] + toNode["width"] / 2, "y": toNode["y"] };
          } else if (toSide == "bottom") {
            toPoint = { "x": toNode["x"] + toNode["width"] / 2, "y": toNode["y"] + toNode["height"] };
          } else if (toSide == "left") {
            toPoint = { "x": toNode["x"], "y": toNode["y"] + toNode["height"] / 2 };
          } else if (toSide == "right") {
            toPoint = { "x": toNode["x"] + toNode["width"], "y": toNode["y"] + toNode["height"] / 2 };
          }
          distances.push({
            "fromSide": fromSide,
            "toSide": toSide,
            "distance": (toPoint.x - fromPoint.x) ** 2 + (toPoint.y - fromPoint.y) ** 2
          });
        }
      }
      distances = distances.sort(function(a, b) {
        return a.distance - b.distance;
      });
      edge["from"]["side"] = distances[0]["fromSide"];
      edge["to"]["side"] = distances[0]["toSide"];
      edge.render();
    }
    canvas.requestSave();
  }
};
